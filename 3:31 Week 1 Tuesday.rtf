{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww13400\viewh17100\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Objective Caml \
\
$ ocaml\
\
# let x = 34;;\
val x : int = 34\
# x;;\
- : int = 34\
# 34.56;;\
- : float = 34.56\
\
FACTORIAL\
//you need to declare it "rec" for recursive\
let rec fact n =\
	match n with //if then else, kind of \
			//inspect n\
			// pattern matching\
		0 -> 1 // if n = 0, return 1\
	          | _ -> n * (fact (n-1)) \
\
//USING THE FILE\
# #use "notes";;\
val fact : int -> int <fun>\
# fact 10;;\
\
\
# 1.0 +. 2.0;; // use "+. for floating point addition, *., /., -. for mult, div, and sub\
- : float = 3.\
\
FACTORIAL 2 // not preferred \
let rec fact2 n = \
	if n=0 then 1 else n * (fact2 (n-1))\
\
\
//LISTS\
# [];;\
- : 'a list = []\
# [1;2;3];;\
- : int list = [1;2;3]\
# ["hi"; "bye"];;\
- : string list = ["hi"; "bye"]\
\
# let myList = [1;2;3];;\
val myList : int list = [1;2;3]\
# 4::myList;; // colon colon  signifies lists.. "cons operator"\
- : int list = [4; 1; 2; 3]\
# myList;;\
- : int list = [1; 2; 3]\
# 1::2::3::[];;\
- : int list = [1; 2; 3]\
\
(* sum the integers in a list *)\
(* : int list -> argument type, : int -> return value *)\
let rec sunList (lst : int list) : int =\
	match let with\
		[] -> 0\
	    | x::xs -> x + ( sumList xs )\
\
# [1;2;3]@[4;5;6];; (* '@' concatenates two lists *)\
- : int list = [1; 2; 3; 4; 5; 6]\
\
(* CONCAT LISTS *)\
let rec concat (l1, l2, \'85) = \
	match l1 with\
		[] -> l2\
	  | x :: xs -> x :: concat (xs, l2)\
\
val concat : 'a list * 'a list -> 'a list = <fun>	\
(* " 'a " represents anything *)\
(* "*" means a pair of\'85 *)\
\
# [(1, "hi"); (2, "bye")];;\
- : (int * string) list = [(1, "hi"); (2, "bye")];\
# [[3;4]; [5;6]];;\
-: int list list = [[3; 4]; [5; 6]]           \
\
\
(* ADD PAIRS OF ELEMENTS *)\
let rec sumConsecutive lst =\
	match lst with\
			[] -> []\
	     	        | [_] -> lst\
               | x1 :: x2 :: xs -> (x1 + x2) :: (sumConsecutive xs)\
\
\
(* TWO SIMPLE FUNCTIONS *)\
let add (x,y) = x+y)\
\
let three () = 3 (* type "unit" *)\
\
# add (three (), 45);;\
- : int = 48\
\
(* ZIP FUNCTION *)\
(* zip ([1;2;3], [4;5;6])  returns [(1,4); (2,5); (3,6)] *)\
let rec zip args =\
	match args with\
		([], []) -> []\
		| (x :: xs, y :: yx) -> (x,y) :: zip(xs, ys)\
	\
(* ONLY CONSTANT TIME FOR HEAD OF LIST *)\
\
\
\
\
\
\
\
\
\
\
\
\
\
}