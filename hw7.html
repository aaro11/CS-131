<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
lang="en"><head><title>Homework 7</title>
</head>


<body>

<h1>Homework 7</h1>

<h2>Due Wednesday, June 1, at 11:30pm</h2>

<h3>Turn in your homework as a single Prolog file
<tt>hw7.pl</tt> via the course web page.</h3>

<h3>Recall the CS131 Academic Honesty Policy!  You must say who you
discussed the assignment with at the top of your assignment, and also  what
other resources you used.</h3>

<p>You may define any number of helper predicates as needed to solve the
following problems.

<ol>
<li>Implement a predicate <tt>duplist(X,Y)</tt> which succeeds whenever
  list <tt>Y</tt> is simply list <tt>X</tt> with each element duplicated.
  For example:

<pre>
| ?- duplist([1,2,3], Y).

Y = [1,1,2,2,3,3]
</pre>

Make sure that your predicate works in both directions.  For example, you should
be able to ask the query <tt>duplist(X, [1,1,2,2,3,3])</tt> and get the right
value of <tt>X</tt>.<p></li>


<li>Define a predicate <tt>sorted(X)</tt> that succeeds if the elements of
  the integer list <tt>X</tt> are in sorted order from least to greatest.
  Duplicate elements are allowed.<b>You may not use any of the built-in sorting predicates.</b><p></li>


<li>
Define a predicate <tt>subseq(X,Y)</tt> that succeeds if list <tt>X</tt> is
a <i>subsequence</i> of list <tt>Y</tt>, which means that
<tt>X</tt> can be obtained by removing zero or more elements from
anywhere within
<tt>Y</tt>.  Note that this means that the elements in <tt>X</tt>
have to be in the same order as they are in <tt>Y</tt>.  For example,
<tt>[1,3]</tt> is a subsequence of <tt>[1,2,3]</tt>, but
<tt>[3,1]</tt> is not.
<b>You may not use the built-in predicate
<tt>sublist</tt> in your solution.</b>
  
<p>  In addition to checking whether
one concrete list is a subsequence of another concrete list, your
solution should be able to produce all subsequences of a given
concrete list.  For example:
<pre>
| ?- subseq(X, [1,2]).

X = [1,2] ? ;

X = [1] ? ;

X = [2] ? ;

X = [] ? ;
</pre>
<p></li>

<li>  Consider the 4x4 version of the game Sudoku.
  In this version, you are given a 4x4 grid with numbers between 1 and 4 filled
  in some squares.  The goal is to fill in the remaining squares so that
  each row contains the numbers 1-4 in some order, each column contains
  the numbers 1-4 in some order, and each 2x2 quadrant contains the numbers
  1-4 in some order.

  <p>Define a predicate <tt>sudoku(Initial, Final)</tt> that succeeds if
    <tt>Final</tt> is the solution to the Sudoku puzzle defined
    by <tt>Initial</tt>.  We will represent a 4x4 grid as a list of four lists,
    each inner list representing one row of the grid.  You may assume that
    the given <tt>Initial</tt> list is a list of exactly four lists and that
    each inner list has exactly four elements.

  <p>Here's an example of what your predicate should be able to do:
<pre>
| ?- sudoku([[2,1,_,_],
             [4,_,_,_],
             [_,_,_,4],
             [_,_,1,_]], Solution).

Solution = [[2,1,4,3],[4,3,2,1],[1,2,3,4],[3,4,1,2]] ? ;
</pre>

<p>
<i>Hint: You may find gprolog's <tt>permutation</tt> predicate useful.</i>
<p></li>


<li>The <a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi">Towers of Hanoi</a>
is a classic mathematical puzzle.  It consists
of three pegs and a number of disks of different sizes.  The puzzle
starts with the disks stacked on peg 1,
  in order of size
with the largest disk at the bottom of the stack.  The goal is to
  relocate the entire stack to peg 2, using a sequence of <i>moves</i>.
  Each move can simply take the top disk from one peg (if that peg is nonempty)
  and move it to the
  top of another peg.  However, a disk can never be placed on top of a
  smaller disk.

<p>Define a predicate <tt>towersOfHanoi(Init, Goal, Moves)</tt> that
  succeeds if we can get from the state of the world represented by
  <tt>Init</tt> to the state of the world <tt>Goal</tt> by executing the
  moves represented by <tt>Moves</tt> in order.  Of course, those moves
  must all satisfy the rules defined above for a legal move.
  We will represent a
  state of the world as a list containing three lists, each inner list
  representing
  the contents of one of the pegs from top to bottom.
    We will represent disks as integers,
  with smaller integers representing smaller disks.  Your code should work for
  any number of disks.  The six possible
  moves are represented by the terms <tt>to(peg1,peg2)</tt>, <tt>to(peg1,peg3)</tt>,
  <tt>to(peg2,peg1)</tt>,
 <tt>to(peg2,peg3)</tt>,
 <tt>to(peg3,peg1)</tt>, and
 <tt>to(peg3,peg2)</tt>,
    which respectively denote moving a disk from
  peg 1 to peg 2, from peg 1 to peg 3, etc.  Note that
  <tt>peg1</tt>, <tt>peg2</tt>, and <tt>peg3</tt> are constants representing the
  three pegs.

<p>Here's an example of what your predicate should be able to do:
<pre>
| ?- length(Moves, 7), towersOfHanoi([[1,2,3],[],[]], [[],[1,2,3],[]], Moves).

Moves = [to(peg1,peg2),to(peg1,peg3),to(peg2,peg3),to(peg1,peg2),to(peg3,peg1),to(peg3,peg2),to(peg1,peg2)] ? ;
</pre>

<p>Notice how I use <tt>length</tt> to limit the size of the resulting
list of moves.  This is necessary to do when you test your code, in
order to prevent Prolog from getting stuck
down infinite paths (e.g., continually transferring the same disk back and
  forth between two pegs).

</body></html>
